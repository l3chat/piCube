<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="utf-8" />
    <title>Тессеракт с двумя цветными гипергранями</title>
    <style>
        body {
            margin: 0;
            background: #111;
            color: #eee;
            overflow: hidden;
            font-family: sans-serif;
        }

        canvas {
            position: fixed;
            inset: 0;
            display: block;
        }
    </style>

    <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>

<body>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        /* === сцена === */
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 18);
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        /* === свет === */
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(5, 10, 7);
        dirLight.castShadow = true;
        scene.add(dirLight);
        scene.add(new THREE.AmbientLight(0x404040, 0.7));

        /* === кватернионы === */
        function qMul(a, b) {
            const [ar, ax, ay, az] = a, [br, bx, by, bz] = b;
            return [ar * br - ax * bx - ay * by - az * bz, ar * bx + ax * br + ay * bz - az * by,
            ar * by - ax * bz + ay * br + az * bx, ar * bz + ax * by - ay * bx + az * br];
        }
        const qConj = q => [q[0], -q[1], -q[2], -q[3]];
        function qExpAxis(angle, axis) {
            const c = Math.cos(angle), s = Math.sin(angle);
            if (axis === 'i') return [c, s, 0, 0]; if (axis === 'j') return [c, 0, s, 0]; return [c, 0, 0, s];
        }
        const v4ToQ = v => [v[0], v[1], v[2], v[3]], qToV4 = q => [q[0], q[1], q[2], q[3]];

        /* === проекция 4D→3D === */
        const d = 3.0;
        function project([x, y, z, w]) { const s = d / (d - w); return new THREE.Vector3(x * s, y * s, z * s); }

        /* === вершины и рёбра гиперкуба === */
        function vertices(s = 1) { const V = []; for (let x of [-s, s]) for (let y of [-s, s]) for (let z of [-s, s]) for (let w of [-s, s]) V.push([x, y, z, w]); return V; }
        function edges(V) { const E = []; for (let i = 0; i < V.length; i++)for (let j = i + 1; j < V.length; j++) { let diff = 0; for (let k = 0; k < 4; k++)if (V[i][k] !== V[j][k]) diff++; if (diff === 1) E.push([i, j]); } return E; }
        const V4 = vertices(1), E4 = edges(V4);

        /* === каркас === */
        function makeWire(color) {
            const g = new THREE.BufferGeometry();
            g.setAttribute('position', new THREE.BufferAttribute(new Float32Array(E4.length * 2 * 3), 3));
            const m = new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.5 });
            return new THREE.LineSegments(g, m);
        }
        function updateWire(line, verts3, edges) {
            const arr = line.geometry.attributes.position.array; let idx = 0;
            for (const [i, j] of edges) {
                const a = verts3[i], b = verts3[j];
                arr[idx++] = a.x; arr[idx++] = a.y; arr[idx++] = a.z;
                arr[idx++] = b.x; arr[idx++] = b.y; arr[idx++] = b.z;
            }
            line.geometry.setDrawRange(0, edges.length * 2);
            line.geometry.attributes.position.needsUpdate = true;
        }

        /* === выделим две гиперграни (w=+1 и w=-1) === */
        const indicesWpos = V4.map((v, i) => v[3] === 1 ? i : -1).filter(i => i >= 0);
        const indicesWneg = V4.map((v, i) => v[3] === -1 ? i : -1).filter(i => i >= 0);

        /* === меши для кубиков === */
        function makeCubeMesh(color) {
            const geom = new THREE.BufferGeometry();
            const verts = new Float32Array(8 * 3); // 8 вершин по 3 координаты
            geom.setAttribute('position', new THREE.BufferAttribute(verts, 3));
            // индексы граней куба
            const cubeIdx = [
                0, 1, 2, 0, 2, 3, // нижняя
                4, 5, 6, 4, 6, 7, // верхняя
                0, 1, 5, 0, 5, 4, // передняя
                2, 3, 7, 2, 7, 6, // задняя
                1, 2, 6, 1, 6, 5, // правая
                0, 3, 7, 0, 7, 4  // левая
            ];
            geom.setIndex(cubeIdx);
            geom.computeVertexNormals();
            const mat = new THREE.MeshStandardMaterial({ color, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            return mesh;
        }
        const cubePos = makeCubeMesh(0xff66cc); // розовый
        const cubeNeg = makeCubeMesh(0x66ccff); // голубой

        function updateCubeMesh(mesh, verts3, indices) {
            const arr = mesh.geometry.attributes.position.array;
            indices.forEach((vi, k) => {
                const v = verts3[vi];
                arr[k * 3 + 0] = v.x;
                arr[k * 3 + 1] = v.y;
                arr[k * 3 + 2] = v.z;
            });
            mesh.geometry.attributes.position.needsUpdate = true;
            mesh.geometry.computeVertexNormals();
        }

        /* === создаём каркас всего куба === */
        const wireAll = makeWire(0xffffff); scene.add(wireAll);

        /* === вращение === */
        function rotatedProjectedVertices(qL, qR, verts4) {
            const qRinv = qConj(qR);
            return verts4.map(v => {
                const vq = qMul(v4ToQ(v), qRinv);
                const v2 = qMul(qL, vq);
                return project(qToV4(v2));
            });
        }

        /* === анимация === */
        let t = 0;
        function animate() {
            requestAnimationFrame(animate);
            t += 0.01;
            const alpha = 1.2 * t, beta = 0.6 * t;
            const qL = qExpAxis(0.5 * (alpha + beta), 'i');
            const qR = qExpAxis(0.5 * (alpha - beta), 'i');
            const verts3 = rotatedProjectedVertices(qL, qR, V4);

            updateWire(wireAll, verts3, E4);
            updateCubeMesh(cubePos, verts3, indicesWpos);
            updateCubeMesh(cubeNeg, verts3, indicesWneg);

            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>

</html>