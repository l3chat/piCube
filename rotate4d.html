<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="utf-8" />

  <title>Тессеракты и квадраты с ярким светом и толстыми хвостами</title>

  <style>
    body {
      margin: 0;
      background: #111;
      color: #eee;
      overflow: hidden;
      font-family: sans-serif;
    }

    canvas {
      position: fixed;
      inset: 0;
      z-index: 0;
      display: block;
    }

    .label {
      position: fixed;
      top: 8px;
      width: 33%;
      text-align: center;
      font-size: 14px;
      opacity: .9;
      pointer-events: none;
      z-index: 10;
    }

    #l1 {
      left: 0;
    }

    #l2 {
      left: 33%;
    }

    #l3 {
      right: 0;
    }

    #controls {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #222;
      color: #eee;
      padding: 6px;
      font-size: 13px;
      display: flex;
      gap: 20px;
      align-items: center;
      flex-wrap: wrap;
      z-index: 20;
    }

    #controls label {
      white-space: nowrap;
    }

    #controls input {
      flex: 1;
    }

    #controls button {
      padding: 4px 10px;
      background: #444;
      color: #eee;
      border: 1px solid #666;
      cursor: pointer;
    }

    #controls button:hover {
      background: #666;
    }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>

<body>
  <div id="l1" class="label">XY-поворот</div>
  <div id="l2" class="label">Изоклиническое</div>
  <div id="l3" class="label">Двойное</div>

  <div id="controls">
    <label>Хвосты: <input id="countSlider" type="range" min="1" max="16" value="16"></label>
    <label>Длина: <input id="lenSlider" type="range" min="10" max="400" value="200"></label>
    <label>Толщина: <input id="thicknessSlider" type="range" min="5" max="200" value="100"></label>
    <label>Скорость: <input id="speedSlider" type="range" min="10" max="300" value="100"></label>
    <label><input id="wireframeToggle" type="checkbox" checked> Каркас</label>
    <label><input id="lightToggle" type="checkbox" checked> Освещение</label>
    <button id="pauseBtn">⏸ Пауза</button>
    <button id="fullscreenBtn">⛶ Полный экран</button>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    /* === параметры === */
    let activeTrails = 16;
    let trailLength = 200;
    let trailThickness = 1.0;
    let speed = 1.0;
    let showWireframes = true;
    let useLighting = true;
    let paused = false;

    /* === элементы управления === */
    document.getElementById("countSlider").addEventListener("input", e => {
      activeTrails = parseInt(e.target.value);
    });
    document.getElementById("lenSlider").addEventListener("input", e => {
      trailLength = parseInt(e.target.value);
    });
    document.getElementById("thicknessSlider").addEventListener("input", e => {
      trailThickness = parseInt(e.target.value) / 100;
    });
    document.getElementById("speedSlider").addEventListener("input", e => {
      speed = parseInt(e.target.value) / 100;
    });
    document.getElementById("wireframeToggle").addEventListener("change", e => {
      showWireframes = e.target.checked;
      [...cubeBlocks, ...squareBlocks].forEach(b => b.wire.visible = showWireframes);
    });
    document.getElementById("lightToggle").addEventListener("change", e => {
      useLighting = e.target.checked;
      updateLighting();
    });
    document.getElementById("pauseBtn").addEventListener("click", e => {
      paused = !paused;
      e.target.textContent = paused ? "▶ Старт" : "⏸ Пауза";
    });
    document.getElementById("fullscreenBtn").addEventListener("click", () => {
      if (!document.fullscreenElement) {
        document.body.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
    });

    /* === сцена === */
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, 28);
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    /* === освещение === */
    let dirLight, ambLight;
    function setupLighting() {
      dirLight = new THREE.DirectionalLight(0xffffff, 11.5);
      dirLight.position.set(5, 10, 7);
      dirLight.castShadow = true;
      dirLight.shadow.mapSize.width = 2048;
      dirLight.shadow.mapSize.height = 2048;
      dirLight.shadow.camera.near = 0.5;
      dirLight.shadow.camera.far = 80;
      dirLight.shadow.camera.left = -30;
      dirLight.shadow.camera.right = 30;
      dirLight.shadow.camera.top = 30;
      dirLight.shadow.camera.bottom = -30;
      scene.add(dirLight);

      ambLight = new THREE.AmbientLight(0x404040, 0.8);
      scene.add(ambLight);
    }
    function updateLighting() {
      dirLight.visible = useLighting;
      ambLight.visible = useLighting;
    }
    setupLighting();
    updateLighting();

    /* === плоскость для теней === */
    const planeGeom = new THREE.PlaneGeometry(120, 120);
    const planeMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 1 });
    const plane = new THREE.Mesh(planeGeom, planeMat);
    plane.rotation.x = -Math.PI / 2;
    plane.position.y = -8;
    plane.receiveShadow = true;
    scene.add(plane);

    /* === кватернионы === */
    function qMul(a, b) {
      const [ar, ax, ay, az] = a, [br, bx, by, bz] = b;
      return [ar * br - ax * bx - ay * by - az * bz, ar * bx + ax * br + ay * bz - az * by,
      ar * by - ax * bz + ay * br + az * bx, ar * bz + ax * by - ay * bx + az * br];
    }
    const qConj = q => [q[0], -q[1], -q[2], -q[3]];
    function qExpAxis(angle, axis) {
      const c = Math.cos(angle), s = Math.sin(angle);
      if (axis === 'i') return [c, s, 0, 0]; if (axis === 'j') return [c, 0, s, 0]; return [c, 0, 0, s];
    }
    const v4ToQ = v => [v[0], v[1], v[2], v[3]], qToV4 = q => [q[0], q[1], q[2], q[3]];

    /* === проекция 4D→3D === */
    const d = 3.0;
    function project([x, y, z, w]) { const s = d / (d - w); return new THREE.Vector3(x * s, y * s, z * s); }

    /* === хвост InstancedMesh === */
    function makeTrail(baseColor) {
      const geo = new THREE.SphereGeometry(0.04, 12, 12); // толще
      const mat = new THREE.MeshStandardMaterial({ color: baseColor, roughness: 0.35, metalness: 0.05 });
      const inst = new THREE.InstancedMesh(geo, mat, 400);
      inst.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      inst.castShadow = true;
      inst.receiveShadow = true;
      inst.count = 0;

      const dummy = new THREE.Object3D();
      const points = [];

      function pushLocal(pos, active) {
        if (!active) { inst.count = 0; points.length = 0; return; }
        points.unshift(pos.clone());
        if (points.length > trailLength) points.pop();

        const N = points.length;
        for (let i = 0; i < N; i++) {
          const age = 1 - i / (N - 1 || 1);
          const scale = trailThickness * (1.5 * age + 0.2); // толще
          dummy.position.copy(points[i]);
          dummy.scale.set(scale, scale, scale);
          dummy.updateMatrix();
          inst.setMatrixAt(i, dummy.matrix);
        }
        inst.count = N;
        inst.instanceMatrix.needsUpdate = true;
      }
      return { mesh: inst, pushLocal };
    }

    /* === радуга цветов === */
    function rainbowColors(n) {
      const out = []; for (let i = 0; i < n; i++) { const hue = i / n; out.push(new THREE.Color().setHSL(hue, 1, 0.55)); }
      return out;
    }
    const vertexColors = rainbowColors(16);
    const shuffledIndices = [...Array(16).keys()].sort(() => Math.random() - 0.5);

    /* === куб === */
    function vertices(s = 1) { const V = []; for (let x of [-s, s]) for (let y of [-s, s]) for (let z of [-s, s]) for (let w of [-s, s]) V.push([x, y, z, w]); return V; }
    function edges(V) { const E = []; for (let i = 0; i < V.length; i++)for (let j = i + 1; j < V.length; j++) { let diff = 0; for (let k = 0; k < 4; k++)if (V[i][k] !== V[j][k]) diff++; if (diff === 1) E.push([i, j]); } return E; }
    const V4 = vertices(1), E4 = edges(V4);

    function makeWire(color) {
      const g = new THREE.BufferGeometry();
      g.setAttribute('position', new THREE.BufferAttribute(new Float32Array(E4.length * 2 * 3), 3));
      const m = new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.9 });
      return new THREE.LineSegments(g, m);
    }
    function updateWire(line, verts3) {
      const arr = line.geometry.attributes.position.array; let idx = 0;
      for (const [i, j] of E4) {
        const a = verts3[i], b = verts3[j];
        arr[idx++] = a.x; arr[idx++] = a.y; arr[idx++] = a.z;
        arr[idx++] = b.x; arr[idx++] = b.y; arr[idx++] = b.z;
      }
      line.geometry.attributes.position.needsUpdate = true;
    }

    function makeBlock(color, xOffset, yOffset) {
      const g = new THREE.Group();
      g.position.x = xOffset;
      g.position.y = yOffset;
      g.rotation.x = -0.25;
      g.rotation.y = 0.35;

      const wire = makeWire(color);
      g.add(wire);

      const trails = [], markers = [];
      for (let i = 0; i < 16; i++) {
        const trail = makeTrail(vertexColors[i]);
        g.add(trail.mesh);
        trails.push(trail);

        const m = new THREE.Mesh(
          new THREE.SphereGeometry(0.04, 12, 12),
          new THREE.MeshStandardMaterial({ color: vertexColors[i], roughness: 0.35, metalness: 0.05 })
        );
        m.castShadow = true; m.receiveShadow = true;
        g.add(m); markers.push(m);
      }

      scene.add(g);
      return { group: g, wire, trails, markers };
    }
    const L = makeBlock(0x66ccff, -6, -4);
    const M = makeBlock(0x99ff99, 0, -4);
    const R = makeBlock(0xff9966, 6, -4);

    /* === квадрат === */
    const SqV4 = [[-1, -1, 0, 0], [1, -1, 0, 0], [1, 1, 0, 0], [-1, 1, 0, 0]];
    const SqE = [[0, 1], [1, 2], [2, 3], [3, 0]];
    function updateSquareLine(line, verts3) {
      const arr = line.geometry.attributes.position.array; let idx = 0;
      for (const [i, j] of SqE) {
        const a = verts3[i], b = verts3[j];
        arr[idx++] = a.x; arr[idx++] = a.y; arr[idx++] = a.z;
        arr[idx++] = b.x; arr[idx++] = b.y; arr[idx++] = b.z;
      }
      line.geometry.attributes.position.needsUpdate = true;
    }
    function makeSquareBlock(color, xOffset) {
      const g = new THREE.Group();
      g.position.x = xOffset; g.position.y = 6;
      g.rotation.x = -0.25; g.rotation.y = 0.35;

      const geom = new THREE.BufferGeometry();
      geom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(SqE.length * 2 * 3), 3));
      const mat = new THREE.LineBasicMaterial({ color });
      const line = new THREE.LineSegments(geom, mat);
      g.add(line);

      const trails = [], markers = [];
      for (let i = 0; i < 4; i++) {
        const trail = makeTrail(color);
        g.add(trail.mesh);
        trails.push(trail);

        const m = new THREE.Mesh(
          new THREE.SphereGeometry(0.04, 12, 12),
          new THREE.MeshStandardMaterial({ color, roughness: 0.35, metalness: 0.05 })
        );
        m.castShadow = true; m.receiveShadow = true;
        g.add(m); markers.push(m);
      }

      scene.add(g);
      return { group: g, wire: line, trails, markers };
    }
    const SqL = makeSquareBlock(0x66ccff, -6);
    const SqM = makeSquareBlock(0x99ff99, 0);
    const SqR = makeSquareBlock(0xff9966, 6);

    const cubeBlocks = [L, M, R];
    const squareBlocks = [SqL, SqM, SqR];

    /* === вращение === */
    function rotatedProjectedVertices(qL, qR, verts4) {
      const qRinv = qConj(qR);
      return verts4.map(v => {
        const vq = qMul(v4ToQ(v), qRinv);
        const v2 = qMul(qL, vq);
        return project(qToV4(v2));
      });
    }

    /* === анимация === */
    let t = 0;
    function animate() {
      requestAnimationFrame(animate);
      if (!paused) t += 0.01 * speed;
      const pick = new Set(shuffledIndices.slice(0, activeTrails));

      // XY
      {
        const qL = qExpAxis(+0.5 * 1.0 * t, 'i'); const qR = qExpAxis(-0.5 * 1.0 * t, 'i');
        const verts3 = rotatedProjectedVertices(qL, qR, V4);
        updateWire(L.wire, verts3);
        verts3.forEach((p, i) => { const active = pick.has(i); L.markers[i].visible = active; L.markers[i].position.copy(p); L.trails[i].pushLocal(p, active); });
        const sqVerts3 = rotatedProjectedVertices(qL, qR, SqV4.map(v => [v[0], v[1], v[2], v[3] + 0.5]));
        updateSquareLine(SqL.wire, sqVerts3);
        sqVerts3.forEach((p, i) => { SqL.markers[i].position.copy(p); SqL.trails[i].pushLocal(p, true); });
      }
      // изоклиническое
      {
        const qL = qExpAxis(0.8 * t, 'i'), qR = [1, 0, 0, 0];
        const verts3 = rotatedProjectedVertices(qL, qR, V4);
        updateWire(M.wire, verts3);
        verts3.forEach((p, i) => { const active = pick.has(i); M.markers[i].visible = active; M.markers[i].position.copy(p); M.trails[i].pushLocal(p, active); });
        const sqVerts3 = rotatedProjectedVertices(qL, qR, SqV4.map(v => [v[0], v[1], v[2], v[3] + 0.5]));
        updateSquareLine(SqM.wire, sqVerts3);
        sqVerts3.forEach((p, i) => { SqM.markers[i].position.copy(p); SqM.trails[i].pushLocal(p, true); });
      }
      // двойное
      {
        const alpha = 1.2 * t, beta = 0.6 * t;
        const qL = qExpAxis(0.5 * (alpha + beta), 'i'); const qR = qExpAxis(0.5 * (alpha - beta), 'i');
        const verts3 = rotatedProjectedVertices(qL, qR, V4);
        updateWire(R.wire, verts3);
        verts3.forEach((p, i) => { const active = pick.has(i); R.markers[i].visible = active; R.markers[i].position.copy(p); R.trails[i].pushLocal(p, active); });
        const sqVerts3 = rotatedProjectedVertices(qL, qR, SqV4.map(v => [v[0], v[1], v[2], v[3] + 0.5]));
        updateSquareLine(SqR.wire, sqVerts3);
        sqVerts3.forEach((p, i) => { SqR.markers[i].position.copy(p); SqR.trails[i].pushLocal(p, true); });
      }

      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });
  </script>
</body>

</html>