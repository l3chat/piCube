<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Минимальный тессеракт 4D → 3D</title>
  <style>
    html,
    body {
      margin: 0;
      height: 100%;
      background: #111;
      color: #eee;
      font-family: system-ui, sans-serif;
    }

    canvas {
      display: block;
    }

    .note {
      position: fixed;
      left: 10px;
      top: 10px;
      font-size: 12px;
      opacity: .8;
    }
  </style>
</head>

<body>
  <div class="note">Двойное вращение тессеракта (XY и ZW). Нет OrbitControls.</div>

  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script>
    // ===== Сцена =====
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, 10);

    // ===== 4D математика =====
    function rotXY(th) {
      const c = Math.cos(th), s = Math.sin(th); return [
        c, -s, 0, 0,
        s, c, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1
      ];
    }
    function rotZW(ph) {
      const c = Math.cos(ph), s = Math.sin(ph); return [
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, c, -s,
        0, 0, s, c
      ];
    }
    function matMul(A, B) {
      const C = new Array(16).fill(0);
      for (let i = 0; i < 4; i++) for (let j = 0; j < 4; j++) {
        let s = 0; for (let k = 0; k < 4; k++) s += A[i * 4 + k] * B[k * 4 + j];
        C[i * 4 + j] = s;
      }
      return C;
    }
    function matVec(M, v) {
      const x = v[0], y = v[1], z = v[2], w = v[3];
      return [
        M[0] * x + M[1] * y + M[2] * z + M[3] * w,
        M[4] * x + M[5] * y + M[6] * z + M[7] * w,
        M[8] * x + M[9] * y + M[10] * z + M[11] * w,
        M[12] * x + M[13] * y + M[14] * z + M[15] * w
      ];
    }
    // Проекция 4D→3D по W
    const d = 3.0;
    function project4Dto3D(v) {
      const [x, y, z, w] = v;
      const denom = d - w;
      const s = Math.abs(denom) < 1e-4 ? d / 1e-4 : d / denom;
      return new THREE.Vector3(x * s, y * s, z * s);
    }

    // ===== Тессеракт =====
    function tesseractVertices(size = 1) {
      const s = size, out = [];
      for (let x of [-s, s])
        for (let y of [-s, s])
          for (let z of [-s, s])
            for (let w of [-s, s]) out.push([x, y, z, w]);
      return out;
    }
    function tesseractEdges(V) {
      const E = [];
      for (let i = 0; i < V.length; i++) for (let j = i + 1; j < V.length; j++) {
        let diff = 0; for (let k = 0; k < 4; k++) if (V[i][k] !== V[j][k]) diff++;
        if (diff === 1) E.push([i, j]);
      }
      return E;
    }

    const V4 = tesseractVertices(1);
    const E4 = tesseractEdges(V4);

    const geom = new THREE.BufferGeometry();
    const pos = new Float32Array(E4.length * 2 * 3);
    geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    const mat = new THREE.LineBasicMaterial({ color: 0x66ccff, transparent: true, opacity: 0.95 });
    const lines = new THREE.LineSegments(geom, mat);
    scene.add(lines);

    // Небольшой наклон для наглядности
    lines.rotation.x = -0.25;
    lines.rotation.y = 0.35;

    function updateGeom(M) {
      const verts3 = V4.map(v => project4Dto3D(matVec(M, v)));
      const arr = geom.attributes.position.array; let idx = 0;
      for (const [i, j] of E4) {
        const a = verts3[i], b = verts3[j];
        arr[idx++] = a.x; arr[idx++] = a.y; arr[idx++] = a.z;
        arr[idx++] = b.x; arr[idx++] = b.y; arr[idx++] = b.z;
      }
      geom.attributes.position.needsUpdate = true;
    }

    // ===== Анимация =====
    let t = 0;
    function animate() {
      requestAnimationFrame(animate);
      t += 0.01;
      const M = matMul(rotZW(t * 0.7), rotXY(t * 1.0)); // двойное вращение
      updateGeom(M);
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });
  </script>
</body>

</html>