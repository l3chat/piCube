<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="utf-8">
  <title>Три варианта вращения тессеракта с белыми хвостами</title>
  <style>
    body {
      margin: 0;
      background: #111;
      color: #eee;
    }

    canvas {
      display: block;
    }

    .label {
      position: fixed;
      bottom: 12px;
      width: 33%;
      text-align: center;
      font-size: 13px;
      opacity: .8;
    }

    #l1 {
      left: 0;
    }

    #l2 {
      left: 33%;
    }

    #l3 {
      right: 0;
    }
  </style>
</head>

<body>
  <div id="l1" class="label">XY-поворот</div>
  <div id="l2" class="label">Изоклиническое</div>
  <div id="l3" class="label">Двойное</div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
    import { Line2 } from "https://unpkg.com/three@0.160.0/examples/jsm/lines/Line2.js";
    import { LineGeometry } from "https://unpkg.com/three@0.160.0/examples/jsm/lines/LineGeometry.js";
    import { LineMaterial } from "https://unpkg.com/three@0.160.0/examples/jsm/lines/LineMaterial.js";

    // ==== базовая сцена ====
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, 13);

    // ==== 4D математика ====
    function rotXY(th) {
      const c = Math.cos(th), s = Math.sin(th); return [
        c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    }
    function rotZW(ph) {
      const c = Math.cos(ph), s = Math.sin(ph); return [
        1, 0, 0, 0, 0, 1, 0, 0, 0, 0, c, -s, 0, 0, s, c];
    }
    function matMul(A, B) {
      const C = new Array(16).fill(0);
      for (let i = 0; i < 4; i++)for (let j = 0; j < 4; j++)for (let k = 0; k < 4; k++)C[i * 4 + j] += A[i * 4 + k] * B[k * 4 + j];
      return C;
    }
    function matVec(M, v) {
      const [x, y, z, w] = v; return [
        M[0] * x + M[1] * y + M[2] * z + M[3] * w,
        M[4] * x + M[5] * y + M[6] * z + M[7] * w,
        M[8] * x + M[9] * y + M[10] * z + M[11] * w,
        M[12] * x + M[13] * y + M[14] * z + M[15] * w];
    }
    const d = 3.0;
    function project(v) { const [x, y, z, w] = v; const s = d / (d - w); return new THREE.Vector3(x * s, y * s, z * s); }

    // ==== тессеракт ====
    function vertices(s = 1) { const V = []; for (let x of [-s, s]) for (let y of [-s, s]) for (let z of [-s, s]) for (let w of [-s, s]) V.push([x, y, z, w]); return V; }
    function edges(V) { const E = []; for (let i = 0; i < V.length; i++)for (let j = i + 1; j < V.length; j++) { let diff = 0; for (let k = 0; k < 4; k++)if (V[i][k] !== V[j][k]) diff++; if (diff === 1) E.push([i, j]); } return E; }
    const V4 = vertices(1), E4 = edges(V4);
    function makeWire(color) { const g = new THREE.BufferGeometry(); g.setAttribute('position', new THREE.BufferAttribute(new Float32Array(E4.length * 2 * 3), 3)); const m = new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.95 }); return new THREE.LineSegments(g, m); }
    const left = makeWire(0x66ccff), mid = makeWire(0x99ff99), right = makeWire(0xff9966);
    left.position.x = -4.5; right.position.x = 4.5; scene.add(left, mid, right);
    for (const g of [left, mid, right]) { g.rotation.x = -0.25; g.rotation.y = 0.35; }
    function updateWire(line, verts3) { const arr = line.geometry.attributes.position.array; let idx = 0; for (const [i, j] of E4) { const a = verts3[i], b = verts3[j]; arr[idx++] = a.x; arr[idx++] = a.y; arr[idx++] = a.z; arr[idx++] = b.x; arr[idx++] = b.y; arr[idx++] = b.z; } line.geometry.attributes.position.needsUpdate = true; }

    // ==== хвосты с Line2 ====
    function makeTrail(maxPoints = 600) {
      const geom = new LineGeometry();
      const mat = new LineMaterial({ color: 0xffffff, linewidth: 0.004, transparent: true });
      mat.resolution.set(window.innerWidth, window.innerHeight);
      const line = new Line2(geom, mat);
      line.computeLineDistances();
      const points = new Array(maxPoints).fill(new THREE.Vector3(0, 0, 0));
      return { line, points, maxPoints };
    }

    function updateTrail(trail, pos) {
      // сдвигаем массив и добавляем новую точку
      trail.points.shift();
      trail.points.push(pos.clone());
      // делаем массив координат
      const arr = [];
      const N = trail.maxPoints;
      for (let i = 0; i < N; i++) {
        arr.push(trail.points[i].x, trail.points[i].y, trail.points[i].z);
      }
      trail.line.geometry.setPositions(arr);
    }

    // три хвоста
    const trailL = makeTrail(600);
    const trailM = makeTrail(600);
    const trailR = makeTrail(600);
    scene.add(trailL.line, trailM.line, trailR.line);

    // ==== маркеры-вершины ====
    const markerGeom = new THREE.SphereGeometry(0.07, 16, 16);
    const markerL = new THREE.Mesh(markerGeom, new THREE.MeshBasicMaterial({ color: 0xffffff }));
    const markerM = new THREE.Mesh(markerGeom, new THREE.MeshBasicMaterial({ color: 0xffffff }));
    const markerR = new THREE.Mesh(markerGeom, new THREE.MeshBasicMaterial({ color: 0xffffff }));
    scene.add(markerL, markerM, markerR);

    // ==== анимация ====
    let t = 0;
    function animate() {
      requestAnimationFrame(animate);
      t += 0.01;

      // левый: XY
      {
        const M = rotXY(t * 1.0);
        const verts3 = V4.map(v => project(matVec(M, v)));
        updateWire(left, verts3);
        const p = verts3[0].clone().add(left.position);
        markerL.position.copy(p);
        updateTrail(trailL, p);
      }

      // центр: изоклиническое
      {
        const M = matMul(rotZW(t * 0.8), rotXY(t * 0.8));
        const verts3 = V4.map(v => project(matVec(M, v)));
        updateWire(mid, verts3);
        const p = verts3[0].clone().add(mid.position);
        markerM.position.copy(p);
        updateTrail(trailM, p);
      }

      // правый: двойное
      {
        const M = matMul(rotZW(t * 0.6), rotXY(t * 1.2));
        const verts3 = V4.map(v => project(matVec(M, v)));
        updateWire(right, verts3);
        const p = verts3[0].clone().add(right.position);
        markerR.position.copy(p);
        updateTrail(trailR, p);
      }

      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      // обновляем разрешение для LineMaterial
      trailL.line.material.resolution.set(window.innerWidth, window.innerHeight);
      trailM.line.material.resolution.set(window.innerWidth, window.innerHeight);
      trailR.line.material.resolution.set(window.innerWidth, window.innerHeight);
    });
  </script>
</body>

</html>